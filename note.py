# print("hello")





# output = 0
# print(f"1: {output}")

# def help_me_get_the_answer():
    # output = 3 * 2
    # print(f"2: {output}")
    # return output 
# print(f"3: {output}")



# help_me_get_the_answer()
# print(f"4: {output}")


# output = help_me_get_the_answer()
# print(f"5: {output}")


# output = "None"
# print(f"6: {output}")


# output = None
# print(f"7: {output}")






# output = help_me_get_the_answer()
# print(output)








# o = "OXFORD BOOKWORMS LIBRARY".title()
# print(o)



# print("built a ladder notes 21".title())




# vs code could open these hint
# not notepad++

# def help_me_get_a_apple():
    # """This function is going to help a human
    # get a apple.hhhhhhhhhhhhh"""
    # print("apple")

# help_me_get_a_apple()









# http://patorjk.com/software/taag/#p=display&f=Graffiti&t=Ya-Tao%20Zhao

# logo = '''

# _____.___.              ___________               
# \__  |   |____          \__    ___/____    ____   
 # /   |   \__  \    ______ |    |  \__  \  /  _ \  
 # \____   |/ __ \_ /_____/ |    |   / __ \(  <_> ) 
 # / ______(____  /         |____|  (____  /\____/  
 # \/           \/                       \/         
# '''


 
 
# print(logo)
# print(logo2)
 
 
 
 
 



# remover old dict:
# dict1 = {
    # 'value': 11
# }
# dict2 = dict1

# print(dict1)
# print(dict2)
# print("--------------------------")
# dict1['value'] = 22
# print(dict1)
# print(dict2)





# dict = {
    # "value": 11,
    # "next": None
# }

# print(dict)

# dict.pop("value")
# print(dict)
 
 
 

# 4!
# def factorial(n):
    # if n == 1:
        # return 1
    # return n * factorial(n-1)
 # print(factorial(4))




# def factorial_number(4):
    
    
# for i in range(1,5):
    # print(f"{i}*{i+1}")
    
# print(range(4))



# def factorial(n):    
    # if n == 1:
        # return 1
    # return print(f"4! = {n} * {factorial(n-1)}")

# factorial(4)





# n = input("Enter a number: ")
# factorial = 1
# if int(n) >= 1:
    # for i in range (1,int(n)+1):
        # print(i)
        # factorial = factorial * i
        # print(f"{factorial} * {i}")
# print("Factorail of ",n , " is : ",factorial)



# def factorial(x):
   # n = 1
   # while x > 1:
       # n *= x
       # x -= 1
   # return n

# print (factorial(5))





# def factorial(x):
    # n = 1   # this will store the factorial value
    # while x > 0:
        # n = n*x
        # x -= 1
    # return n






# def factorial(x):

    # while x > 0:

        # print(x)
        
    
# factorial(4)



# def factorial(x):
    # n = x
    # while n >= 0:
        # x = n * (n - 1)
        # n -= 1
    # return x
    
# print(factorial(4))






# def factorial(x):
    # n = 1
    # while x > 0:
        # print(x)
        # print(f"{n} * {x}")
        # n = x * n
        # print(f"{n} * {x}")
        # x -= 1
        # print(x)
        # print("----------------")
    # return print(n)

# factorial(4)





# def factorial(x):
    # while x != 1:
        # print(x)
        # for i in range(1, x+1):
            # n = x * (x - i)
            # print(f"{n} = {x} * {(x-i)}")
        # x -= 1
        # print("-------------------------")
    # return print(n)

# factorial(4)










# def factorial(x):
    # while x != 1:
        # print(x)
        # for i in range(1, x+1):
            # n = (x - i)
            
            # print(f"{n} = {x} * {(x-i)}")
        # x -= 1
        # print("-------------------------")
    # return print(n)

# factorial(4)





# for i in range(1,5):
    # print(i, end = "")
    
    
    
    
# for i in range(4, 0, -1):
    # if i == 1:
        # print(i, end = "")
        # break
    # print(i, end = "*")
    



# print(type(4/2))






# py -m venv env



# from math import log
# import numpy as number_python
# import matplotlib.pyplot









# Fibonacci series:
# the sum of two elements defines the next
# a, b = 0, 1
# while a < 100:
    # print(a)
    # a, b = b, a+b






# a = 1
# b = 2
# c = 0
# while a < 100:
    # print(a)
    # c = a + b
    # a = b
    # b = c
    




# users = {'Hans': 'active', 'Éléonore': 'inactive', '景太郎': 'active'}
# print(users)
# for user, status in users.copy().items():
    # if status == 'inactive':
        # del users[user]
        # print(users)






# a = [1, 2, 3, 4, 5]
# b = [i*2 for i in a ]
# print(b)
# c = map(lambda x: x*2, a)
# print(list(c))








# print("This will always be run.")

# def main():
    # print(
    # """
    # This will NOT always be run. 
    # This module's name = {}
    # """
    # .format(__name__))
    
    
 # if __name__ == "__main__":
    # main()
# else:
    # print("this note.py module is run from import.")







# def fullname():
    # return print('arthur')
    ## return 'arthur'
# fullname()







# python object-oriented programming

# class employee:
    # pass
    
# emp_1 = employee()
# emp_2 = employee()

# print(emp_1)
# print(emp_2)












# # print('↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓')
# # print("This will always be run.")


# def main():
    # # print(
    # # """
    
    # # This will NOT always be run. 
    # # This module's name = {}
    # # """
    # # .format(__name__))
    
    
        
    
    # # # class employee:
        # # # pass
        
    # # # emp_1 = employee()
    # # # emp_2 = employee()

    # # # print(emp_1)
    # # # print(emp_2)
    
    # # # emp_1.first = 'Corey'
    # # # emp_1.last = 'Schafer'
    # # # emp_1.email = 'Corey.Schafer@company.com'
    # # # emp_1.pay = '50000'
        
    # # # emp_2.first = 'Test'
    # # # emp_2.last = 'User'
    # # # emp_2.email = 'Test.User@company.com'
    # # # emp_2.pay = '40000'
    
    # # # print()
    # # # print(emp_1.email)
    # # # print(emp_2.email)
    
    # raise_amount = 1.05
    # print(raise_amount)


    # class employee:
        
        # # class variable
        # raise_amount = 1.04
        # print(raise_amount)
        # # print(raise_amount)
        
    
    
    
        # def __init__(self, first, last, pay):
            # # first, last, pay are positional arguments
            # self.first = first
            # # self.first: object's atriburion
            # # first: programmer's input
            # # emp_1.first = "corey"
            # # emp_2.first = 'test'
            # # self = employee's object
            
            # self.last = last
            # self.pay = pay
            # self.email = first + '.' + last + "@company.com"
            
        
        # def fullname(self):
            # return '{} {}'.format(self.first, self.last)
            
            
            
        # def apply_raise(self):
            # print(raise_amount)
            # print(employee.raise_amount)
            # print(self.raise_amount)
            
            # self.pay = int(self.pay * self.raise_amount )
            # return self.pay
            
        
    # emp_1 = employee('yatao', 'zhao', 50000)
    # emp_2 = employee('arthur', 'run', 60000)
    
    # # print()
    # # print(emp_1)
    # # print(emp_1.first, emp_1.last, emp_1.pay)
    # # print(emp_2.first)
    
    # # print()
    # # print('{} {}'.format(emp_1.first, emp_1.last))    
    
    # # # fullname()
    
    # # # print(emp_1.fullname)
    # # # fullname(emp_1)
    # # # emp_1.fullname()
    # # print(emp_1.fullname())  # clear code way
    # # print(emp_2.fullname())
    # # print()
    
    
    # # print(employee.fullname(emp_1)) # better understand way
    # # # class.method.arguments
    
    # # print(emp_1.pay)
    # # emp_1.apply_raise()
    # # print(emp_1.pay)
    
    # print(emp_1.pay)
    # print(employee.apply_raise(emp_1))
    
    # print(employee.__name__)
    
    
        


# print(main.__name__)    
# if __name__ == "__main__":
    # main()
# else:
    # print("this note.py module is run from import.")
















# print("This will always be run.")

# def main():
    # print("This will be run when you do not import this.")
    # print('What\'s up?')
    
    
# if __name__ == "__main__":
    # main()
# else:
    # print("this note.py module is run from import.")
    
    
    






# f(x) = x + 10  ## x belong Z
# f(1) = 11


# def f(x):
    # y = x + 10
    # print(y) 

# f(1)










# turtle.pencolor('blue')
# for line in range(4):
    # turtle.forward(100)
    # turtle.left(90)


# turtle.penup()
# turtle.forward(-20)
# turtle.left(90)
# turtle.forward(-20)
# turtle.pendown()
# turtle.right(90)


# turtle.pencolor('green')
# for line in range(4):
    # turtle.forward(140)
    # turtle.left(90)    


# turtle.penup()
# turtle.forward(-20)
# turtle.left(90)
# turtle.forward(-20)
# turtle.pendown()
# turtle.right(90)



# turtle.pencolor('black')
# for line in range(4):
    # turtle.forward(180)
    # turtle.left(90)  








######## draw a lot square by turtle
# import turtle

# for square in range(10):
    # for line in range(4):
        # turtle.forward(100+square*40)
        # turtle.left(90)
        
    # turtle.penup()
    # turtle.forward(-20)
    # turtle.left(90)
    # turtle.forward(-20)
    # turtle.pendown()
    # turtle.right(90)

# turtle.done()










################# print factorial number in human way
# n = 10
# print(str(n) + "! = ", end = '')
# def factorial(n):
    # '''
    # print factorial number in human way
    # '''
    # if n < 0:
        # return 'factorial() not defined for negative values'
    # if n == 0:
        # return 1
    # if n == 1:
        # print('', n, '= ', end = '')
        # return 1
    # else:
        # print('', n, '*', end = '')
        # return n * factorial(n - 1)

# print(factorial(n))












##############
# import math
# print(math.pi)
# print(math.e)
# print(math.tau)












################ download a web table
# import pandas

# simpsons = pandas.read_html('https://en.wikipedia.org/wiki/List_of_The_Simpsons_episodes_(seasons_1%E2%80%9320)')
# print(len(simpsons))
# print(simpsons[1])








##############
# import pandas

# england = pandas.read_csv('https://www.football-data.co.uk/mmz4281/2122/E0.csv')
# print(england)










############ Copy a table in pdf file to csv file
# pip install "camelot-py[cv]"

# import camelot

# table = camelot.read_pdf('foo.pdf', page='1')
# print(table)

# # table.export('foo.csv', f = 'csv')
# table.export('foo.csv')
# # table[0].to_csv('foo.csv')










############## Generate QR code in Python
# pip install pypng, pyqrcode

# import pyqrcode
# import png
# import os

# link = "https://zhaoyatao.com"
# qr_code = pyqrcode.create(link)
# qr_code.png('me.png', scale = 10)
# # qr_code.png('me.png', scale=10, module_color=[0, 255, 0])
# os.system('me.png')











###### replace a new line
# import re

# text = '''
# i
# am 
# a 
# text 
# file
# .
# end.
# '''
# print(text)
# text = re.sub('\n', "\n// ", text)
# print(text)











########### replace a new line 2
# import re
# import os

# text = open('text.txt', 'r')
# text2read = text.read()
# text.close()

# text2 = open('text.txt', 'w')
# text2write = re.sub('\n','\n// ', text2read)
# text2.write(text2write)
# text2.close()

# print('all text have replaced, close text windows will quit.')

# os.system('text.txt')









############# download a youtube video
# import pytube

# url = input("enter video url: ")
# path = "D:\pytube"

# pytube.YouTube(url).streams.get_highest_resolution().download(path)








############# Extract text from PDF
# import PyPDF2
# pdf = open('foo.pdf', "rb")
# reader = PyPDF2.PdfFileReader(pdf)
# page = reader.getPage(0)
# print(page.extractText())










###################       http://www.pythonchallenge.com/pc/def/map.html
# mystr = input('Paste your code: \n')
# print('')
# mappingtbl = mystr.maketrans('ghijklmnopqrstuvwxyzabcdef','ijklmnopqrstuvwxyzabcdefgh')
# print('Mapping table: \n', mappingtbl)
# print('')
# newstr = mystr.translate(mappingtbl)
# print('Translation: \n', newstr)










#########################    30 days of python

# print(
# '''
# 1 1 1 1 1
# 2 1 2 4 8
# 3 1 3 9 27
# 4 1 4 16 64
# 5 1 5 25 125
# ''')




# print('I hope everyone is enjoying the Python Challenge.\nAre you ?') # line break
# print('Days\tTopics\tExercises') # adding tab space or 4 spaces 
# print('Day 1\t3\t5')
# print('Day 2\t3\t5')
# print('Day 3\t3\t5')
# print('Day 4\t3\t5')
# print('This is a backslash  symbol (\\)') # To write a backslash
# print('In every programming language it starts with \"Hello, World!\"') # to write a double quote inside a single quote






# # Strings only
# first_name = 'Asabeneh'
# last_name = 'Yetayeh'
# language = 'Python'
# formated_string = 'I am %s %s. I teach %s' %(first_name, last_name, language)
# print(formated_string)

# # Strings  and numbers
# radius = 10
# pi = 3.14
# area = pi * radius ** 2
# formated_string = 'The area of circle with a radius %d is %.2f.' %(radius, area) # 2 refers the 2 significant digits after the point

# python_libraries = ['Django', 'Flask', 'NumPy', 'Matplotlib','Pandas']
# formated_string = 'The following are python libraries:%s' % (python_libraries)
# print(formated_string) # "The following are python libraries:['Django', 'Flask', 'NumPy', 'Matplotlib','Pandas']"







# language = 'Python'
# a,b,c,d,e,f = language # unpacking sequence characters into variables
# print(a) # P
# print(b) # y
# print(c) # t
# print(d) # h
# print(e) # o
# print(f) # n






############ Count Character Occurrences using Python
# def count_characters(s):
    # count = {}
    # for i in s:
        # if i in count:
            # count[i] += 1
        # else:
            # count[i] = 1
    # print(count)

# word = input('Enter your strings: ')
# count_characters(word)






###################   leetcode 9
# x = 12345
# print(type(x))

# nx = str(x)
# print(type(nx))

# print(nx)
# print(-len(nx))

# print(nx[::-1])








##################  30 days of python
# challenge = 'thirty\t days\t of\t python'
# print(challenge)
# print(challenge.expandtabs())   # 'thirty  days    of      python'
# print(challenge.expandtabs(10)) # 'thirty    days      of        python'






# challenge = 'thirty days of python'
# print(challenge.find('y'))  # 5
# print(challenge.find('th')) # 1



# challenge = 'thirty days of python'
# print(challenge.rfind('y'))  # 16
# print(challenge.rfind('th')) # 17









# challenge = 'thirty days of python'
# print(challenge.swapcase())   # THIRTY DAYS OF PYTHON
# challenge = 'Thirty Days Of Python'
# print(challenge.swapcase())  # tHIRTY dAYS oF pYTHON




# strings = ['Thirty', 'Days', 'Of', 'Python']
# new_str = ' '.join(strings)
# print(new_str)



# company = "Coding For All"
# print(company)

# print(len(company))

# new_company = company.upper()
# print(new_company)

# new_new_company = company.lower()
# print(new_new_company)


# print(company.capitalize())
# print(company.title())
# print(company.swapcase())

# #9
# print(company[0:7])



# #10
# print(company.index('Coding'))



# #11
# #print(company.replace('Coding','Python'))
# company = company.replace('Coding','Python')
# print(company)





# #12
# company = company.replace('All','Everyone')
# print(company)


# company = 'Coding For All'
# print(company.split())


# company = "Facebook, Google, Microsoft, Apple, IBM, Oracle, Amazon"
# print(company.split(','))




# #15
# company = 'Coding For All'
# print(company[0])
# print(company[-1])





# for number in range(6):
    # if number == 3:
        # pass
    # print(number)





# import string
# print(string.ascii_letters) # abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
# print(string.digits)        # 0123456789
# print(string.punctuation)   # !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~









################
# numbers = [-8, -7, -3, -1, 0, 1, 3, 4, 5, 7, 6, 8, 10]
# positive_even_numbers = [ i for i in numbers if i % 2 == 0 and i > 0]
# print(positive_even_numbers)











############ Execution Time
# from time import time
# start = time()

# # code start
# email = input('Enter your Email: ')
# email = email.strip()
# slicer_index = email.index('@')
# username = email[:slicer_index]
# domain_name = email[slicer_index+1:]
# print('Your user name is: ', username, ' and your domain is: ', domain_name)
# # code end

# # clcoding.com
# end = time()
# execution_time = end - start
# print('Execution Time(s): ', execution_time)






########################## Roman to Integer in Python


# class Solution(object):
   # def romanToInt(self, s):
      # """
      # :type s: str
      # :rtype: int
      # """
      # roman = {'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000,'IV':4,'IX':9,'XL':40,'XC':90,'CD':400,'CM':900}
      # i = 0
      # num = 0
      # while i < len(s):
         # if i+1<len(s) and s[i:i+2] in roman:
            # num+=roman[s[i:i+2]]
            # i+=2
         # else:
            # num+=roman[s[i]]
            # i+=1
      # return num
      
      
# ob1 = Solution()
# print(ob1.romanToInt("III"))
# print(ob1.romanToInt("CDXLIII"))






        # 105 ms
        # roman = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000, 'IV':4, 'IX':9, 'XL':40, 'XC':90, 'CD':400, 'CM':900}
        # slicer_s = 0
        # number = 0

        # while slicer_s < len(s):
            # if slicer_s + 1 < len(s) and s[slicer_s:slicer_s+2] in roman:
                # number += roman[s[slicer_s:slicer_s+2]]
                # slicer_s += 2
            # else:
                # number += roman[s[slicer_s]]
                # slicer_s += 1      
        # return number






        # # 65 ms
        # roman = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000, 'IV':4, 'IX':9, 'XL':40, 'XC':90, 'CD':400, 'CM':900}
        # number = 0
        # for i in range(len(s)):
            # # checking the string is the out of the dictionary 
            # if i == len(s):
                # break
            # # checking the string is the last one of the dictionary 
            # if i == len(s) -1:
                # number += roman[s[i]]
                # break
            # if roman[s[i]] >= roman[s[i + 1]]:
                # number += roman[s[i]]
            # else:
                # number -= roman[s[i]]
        # return number










# import numpy

# print(numpy.zeros((3,3)))
# print()
# print(numpy.identity(5))






# import matplotlib.pyplot as plt

# x = range(10)

# y = range(10)
# plt.plot(x, y)
# plt.show()








############### sum of array

# from time import time
# start = time()

# # code start
# email = input('Enter your Email: ')
# email = email.strip()
# slicer_index = email.index('@')
# username = email[:slicer_index]
# domain_name = email[slicer_index+1:]
# print('Your user name is: ', username, ' and your domain is: ', domain_name)
# # code end

# # clcoding.com
# end = time()
# execution_time = end - start
# print('Execution Time(s): ', execution_time)










##########################
# from time import time

# def run_time_decorator(function):
    # def wrapper():
        # start = time()
        
        # result = function()
        
        # end = time()
        # execution_time = end - start
        # print('Execution Time(s): ', execution_time)
        # return result
    # return wrapper
    

# s = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# s1 = range(1,101)
# s2 = range(11, 21)
# s3 = range(21, 31)


# @run_time_decorator
# def find_sum():
    # s1 = range(1,10001)
    # total = 0
    
    # for i in s1:
        # total = total + i 
    # print(total)
    # return total


# # for i in s2:
    # # print(i)

# find_sum()











##########  leetcode:14. Longest Common Prefix

# strs = ["flower","flow","flight"]

# # list to dictionary
# # dict_strs = {strs[i]: 0 for i in range(len(strs))} 

# common = {}
# for x in range_strs:
    # if length_strs == x + 1:
        # break
            
    # if strs[x][x] == strs[x+1][x]:
        
        
        # common[strs[x]] = common[strs[x]] + 1
    

# print(common)





###################################
# import numpy as np
# import matplotlib.pyplot as plt
# import matplotlib.collections as collections


# t = np.arange(0.0, 2, 0.01)
# s1 = np.sin(2*np.pi*t)
# s2 = 1.2*np.sin(4*np.pi*t)

# #subplots?
# fig, ax = plt.subplots()
# ax.set_title('using span_where')
# ax.plot(t, s2, color='black')
# ax.axhline(0, color='blue', lw=2)

# collection = collections.BrokenBarHCollection.span_where(
    # t, ymin=0, ymax=1.2, where=s2 > 0, facecolor='green', alpha=0.5)
# ax.add_collection(collection)

# collection = collections.BrokenBarHCollection.span_where(
    # t, ymin=-1.2, ymax=0, where=s2 < 0, facecolor='red', alpha=0.5)
# ax.add_collection(collection)

# plt.legend()
# plt.show()






########################### Monitoring the keyboard
# from pynput import keyboard

# def on_press(key):
    # try:
        # print('alphanumeric key {0} pressed'.format(
            # key.char))
    # except AttributeError:
        # print('special key {0} pressed'.format(
            # key))

# def on_release(key):
    # print('{0} released'.format(
        # key))
    # if key == keyboard.Key.esc:
        # # Stop listener
        # return False

# # Collect events until released
# with keyboard.Listener(
        # on_press=on_press,
        # on_release=on_release) as listener:
    # listener.join()

# # ...or, in a non-blocking fashion:
# listener = keyboard.Listener(
    # on_press=on_press,
    # on_release=on_release)
# listener.start()





################ 
# f = float(input('please input the temperature(F): '))
# c = (f - 32) / 1.8
# print('%.2f F = %.1f C ' % (f,c))






# def append(self, value):
    # new_node = Node(value)
    # if self.head is None:
        # self.head = new_node
        # self.tail = new_node
    # else:
        # self.tail.next = new_node
        # self.tail = new_node
    # self.length += 1







# def print_items(n):
    # for i in range(n):
        # print(i)
    # for j in range(n):
        # print(j)

# print_items(10)



# def print_items(n):
    # for i in range(n):
        # for j in range(n):
            # print(i,j)
    
# print_items(10)




# def print_items(n):
    # for i in range(n):
        # for j in range(n):
            # for k in range(n):   
                # print(i,j,k)

# print_items(10)




# def print_items(n):
    # for i in range(n):
        # for j in range(n):
            # print(i,j)

    # for k in range(n):
        # print(k)

# print_items(10)





# class Cookie:
    # def __init__(self, color):
        # self.color = color
    # def get_color(self):
        # return self.color
    # def set_color(self, color):
        # self.color = color

# cookie_one = Cookie('green')
# cookie_two = Cookie('blue')

# print('Cookie one is', cookie_one.get_color())
# print('Cookie two is', cookie_two.get_color())

# cookie_one.set_color('yellow')

# print('\nRight now,cookie one is', cookie_one.get_color())
# print('Still, cookie two is', cookie_two.get_color())





# num1 = 11
# num2 = num1

# print("Before value is updated:")
# print("num1 =", num1)
# print("num2 =", num2)

# num1 = 22
# num2 = num1

# print("\nAfter value is updated:")
# print("num1 =", num1)
# print("num2 =", num2)



# dict1 = {
    # 'value':11
# }

# dict2 = dict1

# print('Before value is updated:')
# print("dict1 =", dict1)
# print("dict2 =", dict2)




# dict1 = {
    # 'value':11
# }

# dict2 = dict1

# print('Before value is updated:')
# print("dict1 =", dict1)
# print("dict2 =", dict2)

# dict1['value'] = 22
# dict2 = dict1

# print('\nAfter value is updated:')
# print("dict1 =", dict1)
# print("dict2 =", dict2)



# head = {
    # "value": 11,
    # "next": {
        # "value": 3,
        # "next": {
            # "value": 23,
            # "next": {
                # "value": 7,
                # "next": None
            # }
        # }
    
    # }
# }


# head = {
    # "value": None,
    # "next": None
# }

# print(head['next']['next']['value'])

# print(head['value'])
# print(head['next'])


# class Node:
    # def __init__(self, value):
        # self.value = value
        # self.next = None


# class LinkedList:
    # def __init__(self, value):
        # new_node = Node(value)
        # self.head = new_node
        # self.tail = new_node
        # self.length = 1

# my_linked_list = LinkedList(4)

# print(my_linked_list.head.value)





######################################## append()

# class Node:
    # def __init__(self, value):
        # self.value = value
        # self.next = None


# class LinkedList:
    # def __init__(self, value):
        # new_node = Node(value)
        # self.head = new_node
        # self.tail = new_node
        # self.length = 1


    # def print_list(self):
        # temp = self.head
        # while temp is not None:
            # print(temp.value)
            # temp = temp.next
    
    
    # def append(self, value):
        # new_node = Node(value)
        # if self.head is None:
        # if self.length == 0:
            # self.head = new_node
            # self.tail = new_node
        # else:
            # self.tail.next = new_node
            # self.tail = new_node
        # self.length += 1

# my_linked_list = LinkedList(1)    

# my_linked_list.append(2)

# my_linked_list.print_list()







###########################  desktop notification
# import time
# from plyer import notification

# if __name__ == '__main__':
    # while True:
        # notification.notify(
            # title = 'ALERT!!!',
            # message = "Take a break! It has been 15minutes!",
            # timeout = 10
        # )
        # time.sleep(900)








##################### leetcode14
# strings = ["dog","racecar","car","cat","a","ab","racecaraaaaa","racecara","racecaraa"]

# # strings = ["flower","flow","flight"]
# # strings = ["dog","racecar","car"]
# print()
# print(max(strings))
# print(min(strings))
# print()
# print(ord("a"))
# print(ord("b"))
# print(ord("c"))
# print()
# print(ord("0"))
# print(ord("1"))
# print()
# print("a" > "ab")
# print("ab" > "aba")

# print([0] > [1])
# print(['0'] > ['1'])












################################### pop()


# class Node:
    # def __init__(self, value):
        # self.value = value
        # self.next = None


# class LinkedList:
    # def __init__(self, value):
        # new_node = Node(value)
        # self.head = new_node
        # self.tail = new_node
        # self.length = 1


    # def print_list(self):
        # temp = self.head
        # while temp is not None:
            # print(temp.value)
            # temp = temp.next

    
    # def append(self, value):
        # new_node = Node(value)
        # if self.head is None:
        # # if self.length == 0:
            # self.head = new_node
            # self.tail = new_node
        # else: 
            # self.tail.next = new_node
            # self.tail = new_node
        # self.length += 1




    # def pop(self):

        # # if self.head is None:
        # if self.length == 0:
        
        
            # return None  
        # temp = self.head
        # prev = self.head
        
        
        # while(temp.next):
        # # or, while(temp.next is not None)
        
            # prev = temp
            # temp = temp.next
        # self.tail = prev
        # self.tail.next = None

        # self.length -= 1
        # # self.length = length - 1

        # # remove the last Node
        # if self.length == 0:
            # self.head = None
            # self.tail = None

        # # get the Node we removed 
        # return temp


# my_linked_list = LinkedList(1)
# my_linked_list.append(2)
# my_linked_list.append(3)
# my_linked_list.append(4)



# print('''\n# to remove the last Node, do not care else''')
# my_linked_list.pop()

# print('''\n# to print the linkedlist right now''')
# my_linked_list.print_list()

# print('''\n# to remove the last Node, print it's object''')
# print(my_linked_list.pop())

# print('''\n# to remove the last Node, and get it's value''')
# print(my_linked_list.pop().value)

# print('''\n# to print the linkedlist right now''')
# my_linked_list.print_list()








############################################ prepend()
# class Node:
    # def __init__(self, value):
        # self.value = value
        # self.next = None


# class LinkedList:
    # def __init__(self, value):
        # new_node = Node(value)
        # self.head = new_node
        # self.tail = new_node
        # self.length = 1


    # def print_list(self):
        # temp = self.head
        # while temp is not None:
            # print(temp.value)
            # temp = temp.next

    
    # def append(self, value):
        # new_node = Node(value)
        # if self.head is None:
        # # if self.length == 0:
            # self.head = new_node
            # self.tail = new_node
        # else: 
            # self.tail.next = new_node
            # self.tail = new_node
        # self.length += 1


    # def prepend(self, value):
        # new_node = Node(value)
        # if self.length == 0:
            # self.head = new_node
            # self.tail = new_node
        # else:
            # # added a new Node to the list beginning
            # new_node.next = self.head

            # # to move head to the first Node
            # self.head = new_node

        # self.length += 1
        # return True



# my_linked_list = LinkedList(2)
# my_linked_list.append(3)
# print('''\n# to print the linkedlist right now''')
# my_linked_list.print_list()
# # output: 2, 3

# my_linked_list.prepend(1)
# print('''\n# to print the linkedlist right now''')
# my_linked_list.print_list()
# # output: 1, 2, 3












############################################ pop_first()
# class Node:
    # def __init__(self, value):
        # self.value = value
        # self.next = None


# class LinkedList:
    # def __init__(self, value):
        # new_node = Node(value)
        # self.head = new_node
        # self.tail = new_node
        # self.length = 1


    # def print_list(self):     
        # temp = self.head
        # while temp is not None:
            # print(temp.value)
            # temp = temp.next
        # else:
        # # "else:" equal to "if temp is None:" or "if temp == None:"
            # print(temp)
            
        

    
    # def append(self, value):
        # new_node = Node(value)
        # if self.head is None:
        # # if self.length == 0:
            # self.head = new_node
            # self.tail = new_node
        # else: 
            # self.tail.next = new_node
            # self.tail = new_node
        # self.length += 1

    # def pop_first(self):
        # if self.length == 0:
            # return None

        # temp = self.head
        # self.head = self.head.next
        # temp.next = None
        # self.length -= 1
         
        # # if the linkedlist only have one Node
        # # after call pop_first(), the length of linkedlist is zero
        # # to set tail equal to None
        # if self.length == 0:
            # self.tail = None

        # return temp





# my_linked_list = LinkedList(1)
# my_linked_list.append(2)
# my_linked_list.append(3)


# print('''\n# 1. to print the linkedlist right now''')
# my_linked_list.print_list()
# # output: 1, 2, 3, None
# print()
# print()


# print('''\n# 2. to remove the first Node, do not care else''')
# my_linked_list.pop_first()
# # output: 
# print()
# print()


# print('''\n# 3. to print the linkedlist right now''')
# my_linked_list.print_list()
# # output: 2, 3, None
# print()
# print()


# print('''\n# 4. to remove the first Node, print it's object''')
# print(my_linked_list.pop_first())
# # output: <__main__.Node object at 0x00000260D2E03DF0>
# print()
# print()


# print('''\n# 5. to print the linkedlist right now''')
# my_linked_list.print_list()
# # output: 3, None
# print()
# print()


# print('''\n# 6. to remove the first Node, and get it's value''')
# print(my_linked_list.pop_first().value)
# # output: 3
# print()
# print()


# print('''\n# 7. to print the linkedlist right now''')
# my_linked_list.print_list()
# # output: None









########################## get()
# class Node:
    # def __init__(self, value):
        # self.value = value
        # self.next = None




# class LinkedList:
    # def __init__(self, value):
        # new_node = Node(value)
        # self.head = new_node
        # self.tail = new_node
        # self.length = 1




    # def print_list(self):     
        # temp = self.head
        # while temp is not None:
            # print(temp.value)
            # temp = temp.next
        # else:
        # # "else:" equal to "if temp is None:" or "if temp == None:"
            # print(temp)
            
        

    
    # def append(self, value):
        # new_node = Node(value)
        # if self.head is None:
        # # if self.length == 0:
            # self.head = new_node
            # self.tail = new_node
        # else: 
            # self.tail.next = new_node
            # self.tail = new_node
        # self.length += 1


    # def get(self, index):
        # if index < 0 or index >= self.length:
            # return None
        # temp = self.head
        # for _ in range(index):
            # temp = temp.next
        # return temp


# my_linked_list = LinkedList(0)
# my_linked_list.append(1)
# my_linked_list.append(2)
# my_linked_list.append(3)

# my_linked_list.print_list()
# print()

# print(my_linked_list.get(2).value)










    




##################################### set_value
# class Node:
    # def __init__(self, value):
        # self.value = value
        # self.next = None




# class LinkedList:
    # def __init__(self, value):
        # new_node = Node(value)
        # self.head = new_node
        # self.tail = new_node
        # self.length = 1




    # def print_list(self):     
        # temp = self.head
        # while temp is not None:
            # print(temp.value)
            # temp = temp.next
        # else:
        # # "else:" equal to "if temp is None:" or "if temp == None:"
            # print(temp)
            
        

    # def append(self, value):
        # new_node = Node(value)
        # if self.head is None:
        # # if self.length == 0:
            # self.head = new_node
            # self.tail = new_node
        # else: 
            # self.tail.next = new_node
            # self.tail = new_node
        # self.length += 1



    # def get(self, index):
        # if index < 0 or index >= self.length:
            # return None
        # temp = self.head
        # for _ in range(index):
        # # "_" is not "i", also not going to print(i)
            # temp = temp.next
        # return temp




    # def set_value(self, index, value):
        # temp = self.get(index)
        # # equal to "if index < 0 or index >= self.length: "
        # if temp:
        # # equal to "if temp is not None:"
            # temp.value = value
            # return True
        # return False



# my_linked_list = LinkedList(0)
# my_linked_list.append(1)
# my_linked_list.append(2)
# my_linked_list.append(3)

# my_linked_list.print_list()
# print()


# my_linked_list.set_value(0, 76)
# my_linked_list.print_list()














# ############################## insert()
# class Node:
    # def __init__(self, value):
        # self.value = value
        # self.next = None




# class LinkedList:
    # def __init__(self, value):
        # new_node = Node(value)
        # self.head = new_node
        # self.tail = new_node
        # self.length = 1




    # def print_list(self):     
        # temp = self.head
        # while temp is not None:
            # print(temp.value)
            # temp = temp.next
        # else:
            # print(temp)
            



    # def append(self, value):
        # new_node = Node(value)
        # if self.head is None:
        # # if self.length == 0:
            # self.head = new_node
            # self.tail = new_node
        # else: 
            # self.tail.next = new_node
            # self.tail = new_node
        # self.length += 1




    # def prepend(self, value):
        # new_node = Node(value)
        # if self.length == 0:
            # self.head = new_node
            # self.tail = new_node
        # else:
            # new_node.next = self.head
            # self.head = new_node
        # self.length += 1
        # return True




    # def get(self, index):
        # if index < 0 or index >= self.length:
            # return None
        # temp = self.head
        # for _ in range(index):
            # temp = temp.next
        # return temp





    # def insert(self, index, value):
        # if index < 0 or index > self.length:
            # return False
        # if index == 0:
            # return self.prepend(value)
        # if index == self.length:
            # return self.append(value)
        # new_node = Node(value)
        # temp = self.get(index - 1)
        # new_node.next = temp.next
        # temp.next = new_node
        # self.length += 1
        # return True



# my_linked_list = LinkedList(0)
# my_linked_list.append(1)
# my_linked_list.append(2)
# my_linked_list.append(3)

# my_linked_list.print_list()
# print()


# my_linked_list.insert(1, 76)
# my_linked_list.print_list()














############################### remove()

'''
'''
'''
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None




class LinkedList:
    def __init__(self, value):
        new_node = Node(value)
        self.head = new_node
        self.tail = new_node
        self.length = 1




    def print_list(self):     
        temp = self.head
        while temp is not None:
            print(temp.value)
            temp = temp.next
        else:
            print(temp)
            



    def append(self, value):
        new_node = Node(value)
        if self.head is None:
        # if self.length == 0:
            self.head = new_node
            self.tail = new_node
        else: 
            self.tail.next = new_node
            self.tail = new_node
        self.length += 1
        
        
        
        
        
        
    def pop_first(self):
        if self.length == 0:
            return None
        temp = self.head
        self.head = self.head.next
        temp.next = None
        self.length -= 1
        if self.length == 0:
            self.tail = None
        return temp








    def pop(self):
        if self.length == 0:
            return None  
        temp = self.head
        pre = self.head        
        while(temp.next):
            pre = temp
            temp = temp.next
        self.tail = pre
        self.tail.next = None
        self.length -= 1
        if self.length == 0:
            self.head = None
            self.tail = None
        return temp

        






    def get(self, index):
        if index < 0 or index >= self.length:
            return None
        temp = self.head
        for _ in range(index):
            temp = temp.next
        return temp






        
        
        
    def remove(self, index):
        if index < 0 or index >= self.length:
            return None
            # if this remove() methon is success, it will return a Node,
            # if not, it will return None
            # it is up to success return

        if index == 0:
            return self.pop_first()
        if index == self.length - 1:
            return self.pop()
        prev = self.get(index - 1)
        temp = prev.next
        # do not use "temp = temp.get(index)", because it's complexity is O(n)
        
        prev.next = temp.next
        temp.next = None
        self.length -= 1
        return temp
        
        
my_linked_list = LinkedList(11) 
my_linked_list.append(3)
my_linked_list.append(23)
my_linked_list.append(7)
my_linked_list.print_list()
print()



my_linked_list.remove(2)





print('\n# to print the linkedlist right now')
my_linked_list.print_list()






################################ reverse()
# class Node:
    # def __init__(self, value):
        # self.value = value
        # self.next = None




# class LinkedList:
    # def __init__(self, value):
        # new_node = Node(value)
        # self.head = new_node
        # self.tail = new_node
        # self.length = 1




    # def print_list(self):     
        # temp = self.head
        # while temp is not None:
            # print(temp.value)
            # temp = temp.next
        # else:
            # print(temp)
            



    # def append(self, value):
        # new_node = Node(value)
        # if self.head is None:
        # # if self.length == 0:
            # self.head = new_node
            # self.tail = new_node
        # else: 
            # self.tail.next = new_node
            # self.tail = new_node
        # self.length += 1
        


    # def reverse(self):
        # temp = self.head
        # self.head = self.tail
        # self.tail = temp
        # after = temp.next
        # before = None
        # for _ in range(self.length):
            # after = temp.next
            # temp.next = before
            # before = temp
            # temp = after



# my_linked_list = LinkedList(1)
# my_linked_list.append(2)
# my_linked_list.append(3)
# my_linked_list.append(4)
# my_linked_list.print_list()
# print()

# my_linked_list.reverse()
# my_linked_list.print_list()
















############################### Double linked list



# class Node:
    # def __init__(self, value):
    # # def __init__(self, *args):
    
        # self.value = value
        # # self.value = args
        
        # self.next = None
        # self.prev = None






# class DoubleLinkedList:
    # def __init__(self, value):
    # # def __init__(self, *args):
    
        # new_node = Node(value)
        # # new_node = Node(*args)
        
        
        # self.head = new_node
        # self.tail = new_node        
        # self.length = 1


        
        
    # def print_list(self):
        # # print(self.head.prev)

        # temp = self.head
        # while temp is not None:
            # print(temp.value)
            # temp = temp.next
            
        # # else:
            # # print(temp)




# # my_double_linked_list = DoubleLinkedList()
# # my_double_linked_list = DoubleLinkedList(7,1,3)
# my_double_linked_list = DoubleLinkedList(7)
# my_double_linked_list.print_list()










###################################### Double linked list number 2


# class Node:
    # def __init__(self):
    # # def __init__(self, value):
    # # def __init__(self, *args):
    
        # self.value = None
        # # self.value = value
        # # self.value = args
        
        # self.next = None
        # self.prev = None






# class DoubleLinkedList:

    # def __init__(self):
    # # def __init__(self, value):
    # # def __init__(self, *args):
    
        # new_node = Node()
        # # new_node = Node(value)
        # # new_node = Node(*args)
        
        
        # self.head = new_node
        # self.tail = new_node        
        # self.length = 1


        
        
    # def print_list(self):
        # # print(self.head.prev)

        # temp = self.head
        # while temp is not None:
            # print(temp.value)
            # temp = temp.next
            
        # # else:
            # # print(temp)



# my_double_linked_list = DoubleLinkedList()
# print(type(my_double_linked_list))
# my_double_linked_list.print_list()













###################################### DoubleLinkedList.append()



# class Node:
    # def __init__(self, value):
        # self.value = value        
        # self.next = None
        # self.prev = None





# class DoubleLinkedList:
    # def __init__(self, value):    
        # new_node = Node(value)  
        # self.head = new_node
        # self.tail = new_node        
        # self.length = 1


        
        
        
    # def print_list(self):
        # temp = self.head
        # while temp is not None:
            # print(temp.value)
            # temp = temp.next
            


    # def append(self, value):
        # new_node = Node(value)
        # if self.head is None:
            # self.head = new_node
            # self.tail = new_node
        # else:
            # self.tail.next = new_node
            # new_node.prev = self.tail
            # self.tail = new_node
        # self.length += 1
        # return True







# my_double_linked_list = DoubleLinkedList(1)
# my_double_linked_list.append(2)
# my_double_linked_list.print_list()











################################### DoubleLinkedList


'''
'''
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None
        self.prev = None





class DoubleLinkedList:
    def __init__(self, value):    
        new_node = Node(value)  
        self.head = new_node
        self.tail = new_node        
        self.length = 1


        
        
        
    def print_list(self):
        temp = self.head
        while temp is not None:
            print(temp.value)
            temp = temp.next
            


    def append(self, value):
        new_node = Node(value)
        if self.head is None:
            self.head = new_node
            self.tail = new_node
        else:
            self.tail.next = new_node
            new_node.prev = self.tail
            self.tail = new_node
        self.length += 1
        return True




    def pop(self):
        if self.length == 0:
            return None
        temp = self.tail
        if self.length == 1:
            self.head = None
            self.tail = None
        else:
            self.tail = self.tail.prev
            self.tail.next = None
            temp.prev = None
        self.length -= 1
        return temp
        
        



    def prepend(self, value):
        new_node = Node(value)
        if self.length == 0:
            self.head = new_node
            self.tail = new_node
        else:
            new_node.next = self.head
            self.head.prev = new_node
            self.head = new_node
            self.length += 1
        return True





    def pop_first(self):
        if self.length == 0:
            return None
        temp = self.head
        if self.length == 1:
            self.head = None
            self.tail = None
        else:
            self.head = self.head.next
            self.head.prev = None
            temp.next = None
        self.length -= 1
        return temp






    def get(self, index):
        if index < 0 or index >= self.length:
            return None
        if index < self.length/2:
            temp = self.head
            for _ in range(index):
                temp = temp.next
        else:
            temp = self.tail
            for _ in range(self.length - 1, index, -1):
                temp = temp.prev
        return temp








    def set_value(self, index, value):
        temp = self.get(index)
        if temp:
            temp.value = value
            return True
        return False





    def insert(self, index, value):
        if index < 0 or index > self.length:
            return False
        if index == 0:
            return self.prepend(value)
        if index == self.length:
            return self.append(value)

        new_node = Node(value)
        before = self.get(index - 1)
        after = before.next

        new_node.prev = before
        new_node.next = after
        before.next = new_node
        after.prev = new_node

        self.length += 1
        return True




    def remove(self, index):
        if index < 0 or index >= self.length:
            return None
        if index == 0:
            return self.pop_first()
        if index == self.length - 1:
            return self.pop()

        temp = self.get(index)

        temp.next.prev = temp.prev
        temp.prev.next = temp.next
        temp.next = None
        temp.prev = None

        self.length -= 1
        return temp





my_doubly_linked_list = DoubleLinkedList(1)
my_doubly_linked_list.append(2)
my_doubly_linked_list.append(3)
my_doubly_linked_list.print_list()
print()
'''








################################################## Stack

'''
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None


class Stack:
    def __init__(self, value):
        new_node = Node(value)
        self.top = new_node
        self.height = 1

    def print_stack(self):
        temp = self.top
        while temp is not None:
            print(temp.value)
            temp = temp.next



    def push(self, value):
        new_node = Node(value)
        if self.height == 0:
            self.top = new_node
        else:
            new_node.next = self.top
            self.top = new_node
        self.height += 1




    def pop(self):
        if self.height == 0:
            return None
        temp = self.top
        self.top = self.top.next
        temp.next = None
        self.height -= 1
        return temp






my_stack = Stack(1)
my_stack.print_stack()
print(type(my_stack))
print()

my_stack.push(2)
my_stack.push(3)
my_stack.print_stack()
print()

my_stack.pop()
my_stack.print_stack()
'''






################################## Queue

'''
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None


class Queue:
    def __init__(self, value):
        new_node = Node(value)
        self.first = new_node
        self.last = new_node
        self.length = 1

    def print_queue(self):
        temp = self.first
        while temp is not None:
            print(temp.value)
            temp = temp.next



    def enqueue(self, value):
        new_node = Node(value)
        if self.first is None:
            self.first = new_node
            self.last = new_node
        else:
            self.last.next = new_node
            self.last = new_node
        self.length += 1





    def dequeue(self):
        if self.length == 0:
            return None
        temp = self.first
        if self.length == 1:
            self.first = None
            self.last = None
        else:
            self.first = self.first.next
            temp.next = None
        self.length -= 1
        return temp




my_queue = Queue(1)
my_queue.print_queue()
print(type(my_queue))
print()


my_queue.enqueue(2)
my_queue.enqueue(3)
my_queue.print_queue()
print()

my_queue.dequeue()
my_queue.print_queue()
print()
'''













################# Binary Search Trees

'''
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

class BinarySearchTree:
    def __init__(self):
        self.root = None





    def insert(self, value):
        new_node = Node(value)
        if self.root is None:
            self.root = new_node
            return True
        temp = self.root

        while True:
            if new_node.value == temp.value:
                return False
            if new_node.value < temp.value:
                if temp.left is None:
                    temp.left = new_node
                    return True
                temp = temp.left
            else:
                if temp.right is None:
                    temp.right = new_node
                    return True
                temp = temp.right



    def contains(self, value):
        temp = self.root
        while temp is not None:
            if value < temp.value:
                temp = temp.left
            elif value > temp.value:
                temp = temp.right
            else:
                return True
        return False








my_tree = BinarySearchTree()
print(type(my_tree))
print(my_tree.root)
print()

my_tree.insert(2)
my_tree.insert(1)
my_tree.insert(3)
print(my_tree.root.value)
print(my_tree.root.left.value)
print(my_tree.root.right.value)


print(my_tree.insert(2))
print()

print(my_tree.contains(1))
print(my_tree.contains(7))

'''











####################### Hash table

'''
class HashTable:
    def __init__(self, size = 7):
        self.data_map = [None] * size
    def __hash(self, key):
        my_hash = 0
        for letter in key:
            my_hash = (my_hash + ord(letter) * 23) % len(self.data_map)
        return my_hash
    def print_table(self):
        for i, value in enumerate(self.data_map):
            print(i, ':', value)



    def set_item(self, key, value):
        index = self.__hash(key)
        if self.data_map[index] == None:
            self.data_map[index] = []
        self.data_map[index].append([key, value])




    def get_item(self, key):
        index = self.__hash(key)
        if self.data_map[index] is not None:
            for i in range(len(self.data_map[index])):
                if self.data_map[index][i][0] == key:
                    return self.data_map[index][i][1]
        return None



    def keys(self):
        all_keys = []
        for i in range(len(self.data_map)):
            if self.data_map[i] is not None:
                for j in range(len(self.data_map[i])):
                    all_keys.append(self.data_map[i][j][0])
        return all_keys







my_hash_table = HashTable()
my_hash_table.set_item('bolts', 1400)
my_hash_table.set_item('washers', 50)
my_hash_table.set_item('lumber', 70)

my_hash_table.print_table()
print()

print(my_hash_table.get_item('bolts'))
print(my_hash_table.get_item('washers'))
print(my_hash_table.get_item('llllllll'))
print()


print(my_hash_table.keys())
'''












##################### Hash table interview
# do not use hash table: O(n^2)
'''
def item_in_common(list1, list2):
    for i in list1:
        for j in list2:
            if i == j:
                return True
    return False



list1 = [1,3,5]
list2 = [2,4,5]

print(item_in_common(list1, list2))
'''





'''
# use hash tabel: O(n)
def item_in_common(list1, list2):
    my_dict = {}
    for i in list1:
        my_dict[i] = True

    for j in list2:
        if j in my_dict:
            return True

    return False



list1 = [1,3,5]
list2 = [2,4,5]
print(item_in_common(list1, list2))
'''















'''
class Graph:
    def __init__(self):
        self.adj_list = {}

    def print_graph(self):
        for vertex in self.adj_list:
            print(vertex, ':', self.adj_list[vertex])

    def add_vertex(self, vertex):
        if vertex not in self.adj_list.keys():
            self.adj_list[vertex] = []
            return True
        return False


    def add_edge(self, v1, v2):
        if v1 in self.adj_list.keys() and v2 in self.adj_list.keys():
            self.adj_list[v1].append(v2)
            self.adj_list[v2].append(v1)
            return True
        return False



    def remove_vertex(self, vertex):
        if vertex in self.adj_list.keys():
            for other_vertex in self.adj_list[vertex]:
                self.adj_list[other_vertex].remove(vertex)
            del self.adj_list[vertex]
            return True
        return False







my_graph = Graph()
my_graph.add_vertex('A')
my_graph.print_graph()
print()

my_graph.add_vertex(1)
my_graph.add_vertex(2)

my_graph.add_edge(1,2)
my_graph.print_graph()
print()


my_graph.add_vertex('A')
my_graph.add_vertex('B')
my_graph.add_vertex('C')
my_graph.add_vertex('D')

my_graph.add_edge('A', 'B')
my_graph.add_edge('B', 'C')
my_graph.add_edge('C', 'A')
my_graph.remove_edge('A','B')

my_graph.add_edge('A','B')
my_graph.add_edge('A','C')
my_graph.add_edge('A','D')
my_graph.add_edge('B','D')
my_graph.add_edge('C','D')

my_graph.remove_vertex('D')

my_graph.print_graph()
'''

                    









'''
class Recursion:
    def open_gift_box():
        if ball:
            return ball
        open_gift_box()
'''








####################### Call stack
'''
def funcThree():
    print('Three')


def funcTwo():
    funcThree()
    print('Two')


def funcOne():
    funcTwo()
    print('One')


funcOne()
'''












################ print factorial number in human way

# n = 4
# print(str(n) + "! = ", end = '')
# def factorial(n):
    # '''
    # print factorial number in human way
    # '''
    # if n < 0:
        # return 'factorial() not defined for negative values'
    # if n == 0:
        # return 1
    # if n == 1:
        # print('', n, '= ', end = '')
        # return 1
    # else:
        # print('', n, '*', end = '')
        # return n * factorial(n - 1)


# print(factorial(n))









############################### Bubble sort
'''
def bubble_sort(my_list):
    for i in range(len(my_list) - 1, 0, -1):
        for j in range(i):
            if my_list[j] > my_list[j+1]:
                temp = my_list[j]
                my_list[j] = my_list[j+1]
                my_list[j+1] = temp
    return my_list






def selection_sort(my_list):
    for i in range(len(my_list) - 1):
        min_index = i
        for j in range(i+1, len(my_list)):
            if my_list[j] < my_list[min_index]:
                min_index = j
        if i != min_index:
            temp = my_list[i]
            my_list[i] = my_list[min_index]
            my_list[min_index] = temp
    return my_list





def selection_sort(my_list):
    for i in range(len(my_list) - 1):
        min_index = i
        for j in range(i+1, len(my_list)):
            if my_list[j] < my_list[min_index]:
                min_index = j
        if i != min_index:
            temp = my_list[i]
            my_list[i] = my_list[min_index]
            my_list[min_index] = temp
    return my_list




def merge(list1, list2):
    combined = []
    i = 0
    j = 0
    while i < len(list1) and j < len(list2):
        if list1[i] < list2[j]:
            combined.append(list1[i])
            i += 1
        else:
            combined.append(list2[j])
            j += 1

    while i < len(list1):
        combined.append(list1[i])
        i += 1

    while j < len(list2):
        combined.append(list2[j])
        j += 1

    return combined

       
       
       


def merge_sort(my_list):
    if len(my_list) == 1:
        return my_list
    mid = int(len(my_list) / 2)
    left = my_list[:mid]
    right = my_list[mid:]
    return merge(merge_sort(left), merge_sort(right))





       
print(bubble_sort([4,2,6,5,1,3]))
print()
print(selection_sort([4,2,6,5,1,3]))
print()
print(insertion_sort([4,2,6,5,1,3]))

print()
print(merge([1,2,7,8],[3,4,5,6]))


print()
print(merge_sort([3,1,4,2]))


'''





'''
def swap(my_list, index1, index2):
    temp = my_list[index1]
    my_list[index1] = my_list[index2]
    my_list[index2] = temp



def pivot(my_list, pivot_index, end_index):
# end_index is the last index number of the my_list

    swap_index = pivot_index

    for i in range(pivot_index+1, end_index+1):
    # range(a,b), cannot take b out
    
        if my_list[i] < my_list[pivot_index]:
            swap_index += 1
            swap(my_list, swap_index, i)
            # swap(my_list, 0, 0) equal to not swap
            
    swap(my_list, pivot_index, swap_index)
    return swap_index
    # take out the index, not the value







def quick_sort_helper(my_list, left, right):
    if left < right:
    # look up above the method pivot(), "left" equal to pivot_index, "right" equal to end_index
    
        pivot_index = pivot(my_list, left, right)
        # pivot_index is the swap_index
        
        quick_sort_helper(my_list, left, pivot_index-1)
        quick_sort_helper(my_list, pivot_index+1, right)
        # the pivot_index is lay on the middle of the my_list
        
    return my_list
    # if the my_list has only one number, return it




def quick_sort(my_list):
    return quick_sort_helper(my_list, 0, len(my_list) - 1)








# swap a same index:
my_list3 = [1,2]
swap(my_list3,0,1)
print(my_list3)
swap(my_list3,0,1)
print(my_list3)
swap(my_list3,0,0)
print(my_list3)




my_list = [4,6,1,7,3,2,5]
my_list2 = [4,1,6,7,3,2,5]
print(pivot(my_list, 0, 6))
print(pivot(my_list2, 0, 6))
print(my_list)
print(my_list2)

print()
print(quick_sort([4,6,1,7,3,2,5]))
'''





## tree










